#!/usr/bin/env node

/* eslint-disable max-len */
/* eslint-disable require-jsdoc */

const childProcess = require('child_process');
let isGloballyShuttingDown = false;

const dotenv = require('dotenv');
const fs = require('fs');
const sleep = require('../src/sleep');
const getQueues = require('../src/queues');

process.env.INTEGRATION_TEST_MODE = '1';

const getFile = async file => {
  return await new Promise( (resolve) => {
    fs.readFile(file, 'utf8', (err, data) => {
      console.log(data);
      resolve(data);
    });
  });
};

const getConfig = async () => {
  const envContents = await getFile('./.testnet.localhost.env');
  const buf = Buffer.from(envContents);
  const config = dotenv.parse(buf);
  return config;
};

async function runScript(scriptPath, appContext='') {
  // keep track of whether callback has been invoked to prevent multiple invocations
  const envConfig = await getConfig();

  const options = {env: {...envConfig,
    'APP_CONTEXT': appContext,
    'INTEGRATION_TEST_MODE': 1,
  }};

  return new Promise(resolve => {
    let invoked = false;
    console.log({envConfig});
    const process = childProcess.fork(scriptPath, options);

    // listen for errors as they may prevent the exit event from firing
    process.on('error', function(err) {
      if (invoked) return;
      invoked = true;
      process.kill();
      resolve(err);
    });

    // execute the callback once the process has finished running
    process.on('exit', function(code) {
      if (invoked) return;
      invoked = true;
      const err = code === 0 ? null : new Error('exit code ' + code);
      process.kill();
      resolve(err);
    });
    let intervalID = null;
    function checkShouldExit() {
      if (isGloballyShuttingDown) {
        console.log('EXITING....');
        clearInterval(intervalID);
        invoked = true;
        process.kill();
        resolve(null);
      }
    }

    intervalID = setInterval(checkShouldExit, 500);


    // setTimeout(() => {
    //   console.log('killing sub process!');
    //   isShuttingDown = true;
    //   process.kill();
    // }, 5000);
  });
}

const startServices = async services => {
  services.forEach(service => {
    runScript('./server.js', service);
  });
  await sleep(1000);
};

const clearQueues = async () => {
  const queues = getQueues();
  while (queues.connection.status === 'connecting') {
    await sleep(100);
  }
  const keys = await queues.connection.keys('*integration_test__*');
  if (keys?.length) {
    await queues.connection.del(keys);
  }
  return;
  // const deletePromises = keys.map(key => {
  //   return queues.connection.del(key);
  // });
  // await Promise.all(deletePromises);
};

const initEnv = async () => {
  config = await getConfig();
  Object.keys(config).forEach(configKey => {
    process.env[configKey] = config[configKey];
  });
};

const runScripts = async () => {
  console.log('here51');

  // runScript('./server.js', function(err) {
  //   if (err && !isShuttingDown) {
  //     throw err;
  //   }
  //   console.log('Finished running algodex-service integration test');
  // });
  await initEnv();
  await clearQueues();

  await runScript('./bin/remove-and-create-databases').then(err => {
    if (err && !isGloballyShuttingDown) {
      throw err;
    }
    console.log('Finished remove-and-create-databases');
  });
  await runScript('./bin/add-views').then(err => {
    if (err && !isGloballyShuttingDown) {
      throw err;
    }
    console.log('Finished add-views');
  });

  const services = [
    'algx-balance-worker',
    'asset-worker',
    'block-worker',
    'formatted-order-worker',
    'order-worker',
    'trade-history-worker',
  ];
  await startServices(services);

  await runScript('./bin/sync-sequential').then(err => {
    if (err && !isGloballyShuttingDown) {
      throw err;
    }
    console.log('Finished sync-sequential');
    // resolve('Completed Integration Test');
  });

  isGloballyShuttingDown = true;
  // wait for all processes to shut down
  await sleep(5000);
  process.exit();
};

runScripts();
