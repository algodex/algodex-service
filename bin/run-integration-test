#!/usr/bin/env node

/* eslint-disable max-len */
/* eslint-disable require-jsdoc */

const childProcess = require('child_process');
let isShuttingDown = false;

const dotenv = require('dotenv')
const fs = require('fs');

const getFile = async file => {
  return await new Promise( (resolve) => {
    fs.readFile(file, 'utf8', (err, data) => {
      console.log(data);
      resolve(data);
    });
  });
};

const getConfig = async () => {
  const envContents = await getFile('./.testnet.localhost.env');
  const buf = Buffer.from(envContents);
  const config = dotenv.parse(buf);
  return config;
};

async function runScript(scriptPath, callback) {
  // keep track of whether callback has been invoked to prevent multiple invocations
  let invoked = false;
  const envConfig = await getConfig();

  const options = {env: {...envConfig,
    'APP_CONTEXT': 'algx-balance-worker',
    'INTEGRATION_TEST_MODE': 1,
  }};

  console.log({envConfig});
  const process = childProcess.fork(scriptPath, options);

  // listen for errors as they may prevent the exit event from firing
  process.on('error', function(err) {
    if (invoked) return;
    invoked = true;
    callback(err);
  });

  // execute the callback once the process has finished running
  process.on('exit', function(code) {
    if (invoked) return;
    invoked = true;
    const err = code === 0 ? null : new Error('exit code ' + code);
    callback(err);
  });
  setTimeout(() => {
    console.log('killing sub process!');
    isShuttingDown = true;
    process.kill();
  }, 5000);
}

// Now we can run a script and invoke a callback when complete, e.g.
runScript('./server.js', function(err) {
  if (err && !isShuttingDown) {
    throw err;
  }
  console.log('Finished running algodex-service integration test');
});
