#!/usr/bin/env node
/* eslint-disable require-jsdoc */

/* USAGE:
 *
 * This script will calculate all rewards for the epoch and upload them to the 
 * database.
 *
 * bin/calculate-rewards --epoch={epoch}
 */

require('dotenv').config();
const getDatabases = require('../src/db/get-databases');
const databases = getDatabases();
const formattedEscrowDB = databases.formatted_escrow;
const ownerBalanceDB = databases.owner_balance;
const blockDB = databases.blocks;

const args = require('minimist')(process.argv.slice(2));
if (args.epoch === undefined) {
  throw new Error('Epoch is missing!');
}
const epoch = parseInt(args.epoch);


let seed = 1;
function random() {
  const x = Math.sin(seed++) * 10000;
  return x - Math.floor(x);
}

// const blocksDB = databases.blocks;
// const syncedDB = databases.synced_blocks;


const getSequenceInfo = (escrows) => {
  const unixTimeToChangedEscrows = escrows.reduce( (timeline, escrow) => {
    const times = escrow.data.history.map((historyItem) => historyItem.time);
    times.forEach( (time) => {
      const key = 'ts:'+time;
      if (!(key in timeline)) {
        timeline[key] = [];
      }
      const addrArr = timeline[key];
      addrArr.push(escrow._id); // push escrow address
    });
    return timeline;
  }, {});

  const changedEscrowSeq = Object.keys(unixTimeToChangedEscrows)
      .map((key) => parseInt(key.split(':')[1]));
  changedEscrowSeq.sort();

  return {unixTimeToChangedEscrows, changedEscrowSeq};
};
const getEscrowAndTimeToBalance = (escrows) => {
  const escrowTimeMap = escrows.reduce( (escrowTimeMap, escrow) => {
    escrow.data.history.forEach((historyItem) => {
      const time = historyItem.time;
      const balance = escrow.data.escrowInfo.isAlgoBuyEscrow ?
        historyItem.algoAmount : historyItem.asaAmount;
      const key = escrow._id+':'+time;
      escrowTimeMap[key] = balance;
    });
    return escrowTimeMap;
  }, {});
  return escrowTimeMap;
};

const getSecondsInEpoch = () => {
  return 604800;
};
const getEpochStart = (epoch) => {
  const start = parseInt(process.env.EPOCH_LAUNCH_UNIX_TIME);
  const secondsInEpoch = getSecondsInEpoch();
  return start + (secondsInEpoch * (epoch - 1));
};
const getEpochEnd = (epoch) => {
  return getEpochStart(epoch) + getSecondsInEpoch();
};
const getBlocksToTime = async (blocks) => {
  throw 'PLEASE IMPLEMENT';

  const blockTimeData = await blockDB.query('blocks/blockToTime',
      blocks);
};

const getOwnerBalanceAtTime = (ownerBalanceToHist, ownerAddr, time) => {
  throw 'PLEASE IMPLEMENT';

};

const updateOwnerWallets = ({ownerBalanceHist, escrowStep}) => {
  throw 'PLEASE IMPLEMENT';
};

const getOwnerBalanceDataToHist = (ownerBalanceData) => {
  throw 'PLEASE IMPLEMENT';

  return ownerBalanceData.rows.reduce( (ownerToHist, row) => {
    const owner = row;
    return ownerToHist;
  }, {});
};

const getInitialBalances = (unixTime, escrows) => {
  throw 'PLEASE IMPLEMENT';
};

const updateBalances = ({changedEscrows, walletToBalance,
  escrowTimeToBalance}) => {
    throw 'PLEASE IMPLEMENT';
};

const getSpreads = ({escrowToBalance, escrowAddrToData}) => {
  throw 'PLEASE IMPLEMENT';
};

const updateRewards = ({ownerWalletToRewards, spreads,
  escrowToBalance, escrowAddrToData}) => {

};

async function run() {
  const accountData = await formattedEscrowDB.query('formatted_escrow/epochs', {
    keys: [`${epoch}`]});
  const escrowAddrs = accountData.rows.map(row => row.value);
  
  const formattedEscrowData =
      await formattedEscrowDB.query('formatted_escrow/orderLookup', {
        keys: escrowAddrs});
  const escrows = formattedEscrowData.rows.map(row => row.value);
  const escrowAddrToData =
    formattedEscrowData.rows.reduce((map, row) => map[row._id] = row.value, {});
  const ownerWallets =
    escrows.map( (escrow) => escrow.data.escrowInfo.ownerAddr);
  const ownerBalanceData =
    await ownerBalanceDB.query('owner_balance/ownerAddr', {
      keys: ownerWallets});

  
  const {unixTimeToChangedEscrows, changedEscrowSeq} = getSequenceInfo(escrows);
  const escrowTimeToBalance = getEscrowAndTimeToBalance(escrows);
  const epochStart = getEpochStart(epoch);
  const epochEnd = getEpochEnd(epoch);
  // console.log({changedEscrowSeq});

  // console.log(process.env.COUCHDB_BASE_URL);
  let timestep = epochStart;
  let escrowstep = 0;
  console.log(timestep);
  console.log(epochEnd);
  // console.log(unixTimeToChangedEscrows);
  const escrowToBalance = getInitialBalances(timestep, escrows);
  const ownerWalletToALGXBalance = getInitialOwnerWalletToBalances(timestep,
      ownerBalanceData);
  const ownerWalletToRewards = initWalletToRewards(escrows);
  const ownerBalanceHist = getOwnerBalanceDataToHist(ownerBalanceData);
  let spreads = getSpreads({escrowToBalance, escrowAddrToData});

  do {
    timestep += Math.round(random()*60);
    while (escrowstep < changedEscrowSeq.length &&
          changedEscrowSeq[escrowstep] <= timestep) {
      const changeTime = changedEscrowSeq[escrowstep];
      const changedEscrows = unixTimeToChangedEscrows[`ts:${changeTime}`];
      const escrowDidChange = updateBalances({changedEscrows,
        escrowToBalance, escrowTimeToBalance});
      updateOwnerWallets({ownerWalletToALGXBalance, ownerBalanceHist,
        escrowStep});
      if (escrowDidChange) {
        spreads = getSpreads({escrowToBalance, escrowAddrToData});
      }
      updateRewards({ownerWalletToRewards, spreads,
        escrowToBalance, escrowAddrToData});
      escrowstep++;
    }
    console.log(timestep);
    // console.log(changedEscrowSet);
  } while (timestep < epochEnd);
}

run();
