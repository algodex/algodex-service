#!/usr/bin/env node

require('dotenv').config();
const algosdk = require('algosdk');
const process = require('process');

const {createConsecutiveObject} = require('../src/util');
const {getAppsBlockRange, getBlock} = require('../src/explorer');
const getQueues = require('../src/queues');
const sleep = require('../src/sleep');
// const {exit} = require('process');
const getDatabases = require('../src/db/get-databases');
const databases = getDatabases();
const blocksDB = databases.blocks;
const syncedDB = databases.synced_blocks;
const indexer = require('../src/get-indexer')();
const queues = getQueues();

const getBlockFromDBOrNode = require('../src/get-block-from-db-or-node');
const sleepWhileWaitingForQueues =
  require('../src/sleep-while-waiting-for-queues');
const { TestWatcher } = require('jest');

const compare = async function() {
  if (!process.env.ALGORAND_NETWORK) {
    throw new Error('process.env.ALGORAND_NETWORK is undefined!');
  }
  const apps = [
    {
      id: process.env.ALGORAND_NETWORK === 'testnet' ? 22045503 : 354073718,
      genesis: undefined,
    },
    {
      id: process.env.ALGORAND_NETWORK === 'testnet' ? 22045522: 354073834,
      genesis: undefined,
    },
  ];
  // Get a range of blocks for a list of applications
  const {start, current} = await getAppsBlockRange(indexer, apps);
  let adjStart = start;
  let adjCurrent = current;
  if (process.env.ALGORAND_NETWORK === 'mainnet') {
    adjStart = 19162310; // Start in February 2022
  }

  if (process.env.TESTMODE && process.env.ALGORAND_NETWORK !== 'testnet') {
    throw new Error('TESTMODE is only allowed for testnet');
  }
  if (process.env.TESTMODE) { // Load only 5000 blocks
    //adjStart = 16583454;
    adjStart = 16252573;
    adjCurrent = adjStart + 200;
    // adjCurrent = 16980000;
  }
  adjCurrent = 16980000;
  if (process.env.INTEGRATION_TEST_MODE) {
    adjStart = 16583454;
    adjCurrent = adjStart + 200;
  }

  console.log('start is: ' + adjStart);
  console.log('current is: ' + adjCurrent);
  const rounds = createConsecutiveObject(adjStart, adjCurrent);
  const allDocs = await syncedDB.allDocs();
  const blockDocs = allDocs.rows.filter((doc)=>!isNaN(doc.id));
  // Look in the database for existing blocks and remove them from rounds
  const blocksSet = new Set(blockDocs.map((doc)=>parseInt(doc.id)));
  console.log('here1 ', Object.keys(rounds));
  let hadFirstRound = false;
  for (const round of Object.keys(rounds)) {
    // Important! limit to 1 block at a time for blocks queue
    await sleepWhileWaitingForQueues(['blocks']);
    if (blocksSet.has(parseInt(round))) {
      console.log('Skipping ' + round);
      continue;
    }
    console.log('Queue Round', round);
    let gotBlock = false;

    if (hadFirstRound) {
      // Get block before this round and make sure it exists in the DB
      let foundPrevBlock = false;
      const prevBlock = `${round - 1}`;
      do {
        try {
          await blocksDB.get(prevBlock);
          foundPrevBlock = true;
        } catch (e) {
          // console.log(`${prevBlock} block not yet stored in DB!`);
          await sleep(10);
        }
      } while (!foundPrevBlock);
    }

    do {
      try {
        const block = await getBlockFromDBOrNode(blocksDB, round);
        gotBlock = true;
        await queues.blocks.add('blocks', block, {removeOnComplete: true});
        console.log('Queue Round Sent', round);
      } catch (e) {
        console.log('could not fetch block', {e});
      }
    } while (gotBlock === false);
    hadFirstRound = true;
  }
  console.log('here2');
  process.exit(0);
};


// Run the Sync
(async () => {
  await compare();
})();
